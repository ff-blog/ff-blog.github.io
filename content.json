{"meta":{"title":"老亚瑟博客","subtitle":null,"description":null,"author":"老亚瑟","url":"https://blog.ffspace.cn","root":"/"},"pages":[{"title":"关于本博客","date":"2020-11-02T02:27:52.789Z","updated":"2020-11-02T02:27:52.789Z","comments":true,"path":"categories/关于/index.html","permalink":"https://blog.ffspace.cn/categories/关于/index.html","excerpt":"","text":"简介本博客主要分享技术文章以及在日常工作和学习中阅读和实践过的好文以及一些实用的干货内容。 免责声明本网站文章仅用于技术分享和交流、学习，若侵犯了您的权益，若本博客内容有做得不到位的地方（如：内容若涉及版权或其他改进建议问题） 请及时联系作者进行整改，谢谢！！！ 联系方式邮箱：2011897533@qq.com"},{"title":"","date":"2020-11-02T02:24:16.711Z","updated":"2020-11-02T02:24:16.711Z","comments":true,"path":"categories/前端/index.html","permalink":"https://blog.ffspace.cn/categories/前端/index.html","excerpt":"","text":"暂无文章"},{"title":"","date":"2020-11-02T02:24:16.713Z","updated":"2020-11-02T02:24:16.713Z","comments":true,"path":"categories/随笔/index.html","permalink":"https://blog.ffspace.cn/categories/随笔/index.html","excerpt":"","text":"暂无文章"},{"title":"","date":"2020-11-02T02:24:16.712Z","updated":"2020-11-02T02:24:16.712Z","comments":true,"path":"categories/后端/index.html","permalink":"https://blog.ffspace.cn/categories/后端/index.html","excerpt":"","text":"暂无文章"}],"posts":[{"title":"Intellij IDEA最新全版本永久激活（亲测有效）","slug":"随笔/ideaActivity","date":"2020-05-21T11:00:00.000Z","updated":"2020-11-02T02:24:16.710Z","comments":true,"path":"2020/05/21/随笔/ideaActivity/","link":"","permalink":"https://blog.ffspace.cn/2020/05/21/随笔/ideaActivity/","excerpt":"","text":"前言大家熟知Jetbrains的话应该知道：他们家的所有产品升级到2018.2.1及以上版本后，先前可用的注册服务器都失效了，无法激活升级到最新版本体验最新黑科技。 这次带给大家的是： Jetbrains全系列产品2020.1.1及以下版本（理论上适用于目前所有新老版本到2089年）激活教程（可以永久激活Windows、MAC、Linux），本教程以win，版本v2019.3进行演示 IntelliJ IDEA 官方安装包下载地址（其他版本自行下载） IntelliJ IDEA 全版本激活注册机下载地址（见文章末尾） 安装并破解IDEA 1、下载并安装JetBrains IntelliJ IDEA 2、打开软件，点击“Evaluate”进行试用，然后创建或者打开一个项目工程，进入软件的主界面，如下图所示： 提示1：如果已经处于试用期（之前试用过而且到期了，可以将之前遗留的配置文件夹删除）。提示2：小编选择的是暗黑模式的皮肤，因此后面步骤均为暗黑色！！！ 注意：若原先有配置过hosts的请先删除或注释掉以下地址，否则可能破解失败： 0.0.0.0 account.jetbrains.com 0.0.0.0 www.jetbrains.com 3、将补丁注册机jetbrains-all.zip拖到打开的IntelliJ IDEA软件界面中，弹出对话框并重启idea，如下图所示 4、重启后选择激活方式，并点击激活按钮，再次重启IDEA 5、等待IDEA重启后，即可破解成功，如下图所示，点击Help-&gt;Register查看破解信息，有效期到2089年 IDEA 激活注册机获取扫码关注 “技术干货精选” 公众号，并回复 “idea激活” 免费获取 免责声明：软件收集于网络，仅供技术交流，请勿用于商业及非法用途","categories":[{"name":"随笔","slug":"随笔","permalink":"https://blog.ffspace.cn/categories/随笔/"}],"tags":[{"name":"idea激活","slug":"idea激活","permalink":"https://blog.ffspace.cn/tags/idea激活/"}]},{"title":"Feign微服务间通过@RequestBody进行文件传输","slug":"Feign微服务间通过@RequestBody进行文件传输","date":"2019-12-08T08:00:00.000Z","updated":"2020-11-02T02:24:16.703Z","comments":true,"path":"2019/12/08/Feign微服务间通过@RequestBody进行文件传输/","link":"","permalink":"https://blog.ffspace.cn/2019/12/08/Feign微服务间通过@RequestBody进行文件传输/","excerpt":"","text":"在多数时候，我们都会遇见两个系统间传递文件的需求，对于这种文件传输，在之前单体应用/部署在同一台机子的时候比较好处理。 但是如今在微服务的时代，不同业务拆分成不同的模块系统，同时有可能部署在不同的服务器上，这时候要进行两个服务间传输文件就会相对困难，但并不是没有解决方案： 1、采用oss存储作为唯一媒介，将文件上传到oss上，然后再进行获取 2、使用feign的直接传输，但是必须得引入 feign-form 来进行传输 3、就是写一个Encoder解析器 上面介绍的这几种相对来说比较复杂，但都是可以解决微服务系统间文件传输的问题。而今天我们要介绍的另外一种方案就是直接将文件转为byte，通过普通的@RequestBody形式（即json格式）进行文件传输，该方案可能不太适用于更复杂的场景，但也是笔者在写代码时候发现的另一种方法。 二、具体实现1、本文将介绍使用feign从spring-feign-demo1 以 json形式传递文件到spring-feign-demo2的关键性代码 在spring-cloud-demo2中编写用于接收文件的DTO和Controller。1、Controller层123456789101112131415161718192021@Controllerpublic class FeignController &#123; /** * 接收文件 */ @RequestMapping(value = &quot;/feign/send/file&quot;, method = &#123;RequestMethod.POST&#125;) @ResponseBody public String performController(@RequestBody FeignRequestDTO requestDTO) &#123; try &#123; // 将demo1的文件流保存到该服务器的指定目录下 // 注意：文件名和格式可以通过请求参数定义一个字段传输，这里不做演示 File file = new File(&quot;D:\\\\demo2\\\\新demo1的文件.xlsx&quot;); FileUtils.writeByteArrayToFile(file,requestDTO.getFile()); System.out.println(&quot;成功接收来自demo1的文件&quot;); // todo 读取demo2服务器的文件继续业务处理即可 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return &quot;true&quot;; &#125; 2、demo2的RequestDTO请求对象如下1234567891011121314151617181920212223242526272829public class FeignRequestDTO &#123; /** * 用户编号 */ private String userId; public String getUserId() &#123;return userId;&#125; public void setUserId(String userId) &#123; this.userId = userId;&#125; /** * 用户名 */ private String userName; public String getUserName() &#123; return userName;&#125; public void setUserName(String userName) &#123;this.userName = userName;&#125; /** * 文件流（关键字段） */ private byte[] file; public byte[] getFile() &#123;return file;&#125; public void setFile(byte[] file) &#123;this.file = file;&#125;&#125; 在spring-cloud-demo1中编写调用Demo2的Feign接口并调用。1、Feign接口123456789101112131415@Component@FeignClient(name = &quot;spring-cloud-demo2&quot;)public interface FeignDemo2Interface &#123; /** * feign的对外接口请求方法 * * @param requestDTO * @return */ @RequestMapping(value = &quot;/feign/send/file&quot;, method = &#123;RequestMethod.POST&#125;) @ResponseBody String performController(@RequestBody FeignRequestDTO requestDTO);&#125; 2、demo1中的发送文件到的demo2的Controller12345678910111213141516171819202122232425262728@Controllerpublic class FeignDemo1Controller &#123; @Autowired private FeignDemo2Interface feignDemo2Interface; /** * 处理请求 */ @RequestMapping(value = &quot;/feign/demo1/test&quot;, method = &#123;RequestMethod.GET&#125;) @ResponseBody public void performController() &#123; try &#123; // 读取该服务器本地的文件并转换为byte byte[] bytes = FileUtils.readFileToByteArray(new File(&quot;D:\\\\demo1\\\\demo1的文件.xlsx&quot;)); // 引用demo2的对象将读取的文件进行封装，并调用demo2的方法 FeignRequestDTO requestDTO = new FeignRequestDTO(); requestDTO.setUserId(&quot;10000&quot;); requestDTO.setUserName(&quot;张三&quot;); requestDTO.setFile(bytes); String s = feignDemo2Interface.performController(requestDTO); System.out.println(&quot;发送文件成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 三、结果1、调用demo1的controller后，即可将文件通过feign发送给demo2。","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.ffspace.cn/categories/后端/"},{"name":"Spring Cloud","slug":"后端/Spring-Cloud","permalink":"https://blog.ffspace.cn/categories/后端/Spring-Cloud/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://blog.ffspace.cn/tags/后端/"}]},{"title":"Java使用Tess4J 实现简单的图像识别(Maven版)","slug":"随笔/Java使用Tess4J 实现简单的图像识别(Maven版)","date":"2019-10-08T05:00:00.000Z","updated":"2020-11-02T02:24:16.709Z","comments":false,"path":"2019/10/08/随笔/Java使用Tess4J 实现简单的图像识别(Maven版)/","link":"","permalink":"https://blog.ffspace.cn/2019/10/08/随笔/Java使用Tess4J 实现简单的图像识别(Maven版)/","excerpt":"","text":"一、前言最近有个朋友需要用Java做一个图像识别的东西，因此帮忙参考了网上资料写了一个基于Tess4J简单版的图像识别demo，供参考。 二、简单实例1、首先创建一个新的maven项目（创建教程在此省略，自行百度），将所需jar包引入pom.xml1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.tess4j&lt;/groupId&gt; &lt;artifactId&gt;tess4j&lt;/artifactId&gt; &lt;version&gt;4.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、在任意地方创建一个文件夹tessdata，将下载的chi_sim.traineddata 和 eng.traineddata语言包存放在该目录下，也可以直接存放到自己项目的resources/tessdata目录下。 语言库下载地址：https://github.com/tesseract-ocr/tessdata 3、编写代码1234567891011121314151617181920212223242526 // 识别图片的路径（修改为自己的图片路径）String path = &quot;D:\\\\test.jpg&quot;;// 语言库位置（修改为跟自己语言库文件夹的路径）String lagnguagePath = &quot;D:\\\\tessdata&quot;;File file = new File(path);ITesseract instance = new Tesseract();//设置训练库的位置instance.setDatapath(lagnguagePath);//chi_sim ：简体中文， eng 根据需求选择语言库instance.setLanguage(&quot;eng&quot;);String result = null;try &#123; long startTime = System.currentTimeMillis(); result = instance.doOCR(file); long endTime = System.currentTimeMillis(); System.out.println(&quot;Time is：&quot; + (endTime - startTime) + &quot; 毫秒&quot;);&#125; catch (TesseractException e) &#123; e.printStackTrace();&#125;System.out.println(&quot;result: &quot;);System.out.println(result); 4、测试本文以一张简单的图片为例：图片放置在D:\\test.png根目录下，因此使用代码测试前需要修改代码中指定的两个路径！！！ 识别图片： 运行代码后： 5、可选步骤：配置环境变量（TESSDATA_PREFIX）环境变量地址指向你存放语言包的文件夹路径，如：我的语言包路径在 D:\\tessdata 本文代码参考自：https://blog.csdn.net/zai_xia/article/details/80003778 往期系列文章：Spring Security系列教程ELK日志采集整合教程","categories":[{"name":"随笔","slug":"随笔","permalink":"https://blog.ffspace.cn/categories/随笔/"}],"tags":[{"name":"java","slug":"java","permalink":"https://blog.ffspace.cn/tags/java/"}]},{"title":"RabbitMQ 3.7快速安装教程","slug":"RabbitMQ 3.7快速安装教程","date":"2019-08-11T14:19:00.000Z","updated":"2020-11-02T02:24:16.703Z","comments":true,"path":"2019/08/11/RabbitMQ 3.7快速安装教程/","link":"","permalink":"https://blog.ffspace.cn/2019/08/11/RabbitMQ 3.7快速安装教程/","excerpt":"","text":"一、简介RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而集群和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。 二、准备工作1、rabbitmq-server-3.7.17.exe 官网下载2、otp_win64_22.0.exe 官网下载 三、下载安装包1、首先我们需要准备一个rabbitmq的安装包和Erlang安装包，若没有则百度搜索进入官网页面进行下载。 2、为什么还要下载Erlang？ 这是应为rabbit是基于erlang语言开发的程序，所以提示我们缺少这个运行环境，此时我们直接点击确定进入erlang下载页面，根据自己的系统版本下载安装包。 三、开始安装1、安装包准备好友，首先运行安装Erlang安装程序（注意安装在中文路径下）。 2、按照步骤一直点击Next，中间可以选择更换安装路径，但不能是中文路径，点击“Install”后等待安装完成即可点击“Close”关闭。 3、安装完Erlang程序后，接着我们直接双击打开rabbitMQ安装程序（注意不能安装在中文路径下），按照步骤一直点击Next，中间可以选择更换安装路径，但不能是中文路径，点击“Install”后等待安装完成即可点击“Finish”关闭。 四、最后配置1、到第三步步后，rabbit就已经安装按成了，而且一般完成后，rabbitmq会自动开启。 2、但是RabbitMQ安装后默认是不启动管理模块的，所以需要配置将管理模块启动，才可以通过浏览器访问：localhost:15672，命令如下： 12345// 若没有配置环境变量，运行命令时需要在安装rabbitmq目录下的sbin文件夹执行rabbitmqctl start_apprabbitmq-plugins enable rabbitmq_managementrabbitmqctl stop// 注意：每次运行完买那个了需要重启rabbitmq，以生效 3、配置完成后直接浏览器访问：localhost:15672，能够进入到如下页面则表示rabbitmq安装完成！！！ 默认用户名和密码均是：guest 五、运行rabbitMQ被立刻停止解决方案（作者遇到的问题之一）rabbitmq在windows下运行后立马停止的问题为log和数据库存在中文路径导致的，可以根据如下命令解决： 1234// 停止服务，然后执行以下3条语句：rabbitmq-service.bat remove set RABBITMQ_BASE=D:\\install3\\rabbitmq\\rabbitmq_server-3.7.8\\datarabbitmq-service.bat install 推荐阅读：Spring Security系列教程Spring Boot 集成 ELK + logback 实现日志采集","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.ffspace.cn/categories/后端/"},{"name":"RabbitMQ","slug":"后端/RabbitMQ","permalink":"https://blog.ffspace.cn/categories/后端/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.ffspace.cn/tags/RabbitMQ/"}]},{"title":"Spring Boot 集成 ELK + logback 实现日志采集","slug":"elk/Spring Boot 集成 ELK + logback 实现日志采集","date":"2019-08-09T02:28:00.000Z","updated":"2020-11-02T02:24:16.707Z","comments":true,"path":"2019/08/09/elk/Spring Boot 集成 ELK + logback 实现日志采集/","link":"","permalink":"https://blog.ffspace.cn/2019/08/09/elk/Spring Boot 集成 ELK + logback 实现日志采集/","excerpt":"","text":"ELK简介ELK是三个开源软件的缩写，分别表示：Elasticsearch , Logstash, Kibana , 它们都是开源软件。 Elasticsearch：是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。 Logstash：主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往elasticsearch上去。 Kibana：也是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。 环境1、jdk8 2、elasticsearch-6.4.2.tar.gz 地址：https://www.elastic.co/downloads/elasticsearch 3、logstash-6.4.2.tar.gz 地址：https://www.elastic.co/downloads/logstash 4、kibana-6.4.2-linux-x86_64.tar.gz 地址：https://www.elastic.co/downloads/kibana 一、部署+配置ELK安装 jdklinux 如何安装 jdk1.8 可参照其他网友贡献的文档 https://blog.csdn.net/qq250782929/article/details/51603276 配置 jdk 环境变量 export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_31 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH source /etc/profile 配置环境变量升效 安装 elasticsearchelasticsearch 不能用root账户启动，因此，需要增加一个账户es 123useradd -m espasswd es es 1234567root# tar -xvf elasticsearch-6.4.2.tar.gzroot# cp -rf elasticsearch-6.4.2 /home/esroot# chown -R es.es /home/es/elasticsearch-6.4.2es$ nohup /home/es/elasticsearch-6.4.2/bin/elasticsearch &amp; 启动过程遇到下问题 `[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536] `[2]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 请参照网友提供的解决方案： https://blog.csdn.net/feinifi/article/details/73633235?utm_source=itdadao&amp;utm_medium=referral `[3]: max number of threads [3895] for user [elk] is too low, increase to at least [4096] 修改/etc/security/limits.conf文件，添加或修改如下行：12* hard nproc 4096* soft nproc 4096 重新启动1es$ nohup /home/es/elasticsearch-6.4.2/bin/elasticsearch &amp; 更多elasticsearch配置https://www.elastic.co/guide/en/elasticsearch/reference/current/logging.html 安装 logstash123useradd -m elkpasswd elk elk 12345root# tar -zxvf logstash-6.1.0.tar.gzroot# cp -rf logstash-6.1.0/home/elkroot# chown -R elk.elk /home/elk/logstash-6.1.0elk$ touch /home/elk/logstash-6.1.0/config/logstash-simple.confelk$ ./bin/logstash -f ./config/logstash-simple.conf 在config 下配置一个simple.conf配置文件 123456789101112131415161718192021222324input &#123; tcp &#123; mode =&gt; &quot;server&quot; host =&gt; &quot;本机ip&quot; port =&gt; 9250 &#125; stdin &#123;&#125;&#125;filter &#123; &#125;output &#123; elasticsearch &#123; action =&gt; &quot;index&quot; hosts =&gt; &quot;ip:9200&quot; index =&gt; &quot;logstash-demo&quot; &#125; stdout &#123; codec =&gt; rubydebug &#125;&#125; 安装 kinbana使用命令解压（根据自己的文件名称进行解压）：tar -zxvf kibana-6.4.2-linux-x86_64.tar.gz 修改配置文件:cd /kibana/kibana-6.4.2-linux-x86_64/config/kibana.yml 【修改标注的这三个参数即可】 server.port: 5601 端口 server.host: （linux对应的ip地址） elasticsearch.url: “http://xxx.xxx.xxx.xxx:9200&quot;（根据es配置地址和端口进行配置） 启动：返回解压后cd /kibana/kibana-6.4.2-linux-x86_64/bin 执行：./kibana //不能关闭终端nohup ./kibana &gt; /nohub.out &amp; //可关闭终端，在nohup.out中查看log 备注：如果不能正常访问则使用firewall开放linux端口1、执行如下命令命令：firewall-cmd –zone=public –add-port=5601/tcp –permanent 2、重启防火墙，运行命令：firewall-cmd –reload 3、查看端口号是否开启，运行命令：firewall-cmd –query-port=5601/tcp 二、如何在Logback.xml中集成logstash1、在pom文件中引入jar包1234567891011 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;dependency&gt; &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt; &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt; &lt;version&gt;5.2&lt;/version&gt;&lt;/dependency&gt; 2、在logback-spring.xml中配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;configuration&gt; &lt;!-- 使用下方日志输出格式必须引入默认的xml --&gt; &lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot;/&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;springAppName&quot; source=&quot;spring.application.name&quot;/&gt; &lt;!-- 控制台的日志输出样式 --&gt; &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot; /&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;!-- 日志输出编码 --&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=&quot;STDERR&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;target&gt;System.err&lt;/target&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- This is the kafkaAppender --&gt; &lt;appender name=&quot;kafkaAppender&quot; class=&quot;com.github.danielwegener.logback.kafka.KafkaAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt; &#123; &quot;severity&quot;: &quot;%level&quot;, &quot;service&quot;: &quot;$&#123;springAppName:-&#125;&quot;, &quot;trace&quot;: &quot;%X&#123;X-B3-TraceId:-&#125;&quot;, &quot;span&quot;: &quot;%X&#123;X-B3-SpanId:-&#125;&quot;, &quot;exportable&quot;: &quot;%X&#123;X-Span-Export:-&#125;&quot;, &quot;pid&quot;: &quot;$&#123;PID:-&#125;&quot;, &quot;thread&quot;: &quot;%thread&quot;, &quot;class&quot;: &quot;%logger&#123;40&#125;&quot;, &quot;message&quot;: &quot;%message&quot; &#125; &lt;/pattern&gt; &lt;/encoder&gt; &lt;topic&gt;topic-logback&lt;/topic&gt; &lt;keyingStrategy class=&quot;com.github.danielwegener.logback.kafka.keying.NoKeyKeyingStrategy&quot; /&gt; &lt;deliveryStrategy class=&quot;com.github.danielwegener.logback.kafka.delivery.AsynchronousDeliveryStrategy&quot; /&gt; &lt;!-- Optional parameter to use a fixed partition --&gt; &lt;!-- &lt;partition&gt;0&lt;/partition&gt; --&gt; &lt;!-- Optional parameter to include log timestamps into the kafka message --&gt; &lt;!-- &lt;appendTimestamp&gt;true&lt;/appendTimestamp&gt; --&gt; &lt;!-- bootstrap.servers is the only mandatory producerConfig --&gt; &lt;producerConfig&gt;bootstrap.servers=ip:9092&lt;/producerConfig&gt; &lt;!-- this is the fallback appender if kafka is not available. --&gt; &lt;appender-ref ref=&quot;STDERR&quot; /&gt; &lt;/appender&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;console&quot;/&gt; &lt;appender-ref ref=&quot;kafkaAppender&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; 注意：配置文件中的必须在logstash配置文件topic或topic-pattern能够匹配到才会从kafka读取到消息 配置完成后启动1、启动elk：elasticsearch -&gt; logstash -&gt; kibana 必须根据启动顺序进行启动 2、测试发送日志 推荐阅读：Spring Security系列教程","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.ffspace.cn/categories/后端/"},{"name":"Spring Boot","slug":"后端/Spring-Boot","permalink":"https://blog.ffspace.cn/categories/后端/Spring-Boot/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://blog.ffspace.cn/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.ffspace.cn/tags/Spring-Boot/"},{"name":"日志采集","slug":"日志采集","permalink":"https://blog.ffspace.cn/tags/日志采集/"}]},{"title":"如何快速在github上创建新分支","slug":"如何快速在github上创建新分支","date":"2019-06-12T14:30:00.000Z","updated":"2020-11-02T02:24:16.708Z","comments":true,"path":"2019/06/12/如何快速在github上创建新分支/","link":"","permalink":"https://blog.ffspace.cn/2019/06/12/如何快速在github上创建新分支/","excerpt":"","text":"现阶段网上大部分搜索出来的如何在github上直接创建分支的方式，都是讲直接在项目或者git上创建分支后再push上去即可创建。这虽然也是一种方式之一，但是有时候我们希望能够像国内一样直接在仓库上进行创建。本篇文章将告诉你！！！ 步骤一：打开github官网，选择一个要新增分支的git仓库（若没有则创建） 步骤二：在Code页面左侧Branch点击，出现下拉框 步骤三：在弹出的面板内，直接搜索要创建的新分支名称，会发现没有该分支时，会提示是否创建。点击Create branch：dev 最后：新分支创建完成 以上就是直接在github上快速创建分支教程，希望读者喜欢！！！","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.ffspace.cn/categories/后端/"},{"name":"Github","slug":"后端/Github","permalink":"https://blog.ffspace.cn/categories/后端/Github/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://blog.ffspace.cn/tags/后端/"}]},{"title":"安装mysql8.0出现error 1042，无法正常启动解决方案","slug":"mysql/安装mysql8.0出现error_1042,无法正常启动解决方案","date":"2019-05-30T12:40:00.000Z","updated":"2020-11-02T02:24:16.708Z","comments":true,"path":"2019/05/30/mysql/安装mysql8.0出现error_1042,无法正常启动解决方案/","link":"","permalink":"https://blog.ffspace.cn/2019/05/30/mysql/安装mysql8.0出现error_1042,无法正常启动解决方案/","excerpt":"","text":"一、问题描述mysql已经发展到了8.0阶段，但是很多人在下载了安装了mysql8.0后，在快接近完成的阶段下出现了异常： error 1042：Unable to connect to any of the specified MySQL hosts 上述异常直接导致mysql无法正常Finish，如图所示： 二、解决方案1、windows端使用Win+R –&gt; 运行 “services.msc” –&gt; 打开service服务管理器，找到刚才安装mysql的服务名称 2、右键 –&gt; 属性 –&gt; 登录，更改成“本地系统账户” –&gt; 确定 3、回到安装程序，在次点击Execute，会发现已经可以成功到Finish界面 推荐阅读：Spring Security系列教程","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.ffspace.cn/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.ffspace.cn/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.ffspace.cn/tags/数据库/"}]},{"title":"Jmeter测试脚本编写","slug":"测试/Jmeter测试脚本编写","date":"2019-05-30T12:40:00.000Z","updated":"2020-11-02T02:24:16.709Z","comments":true,"path":"2019/05/30/测试/Jmeter测试脚本编写/","link":"","permalink":"https://blog.ffspace.cn/2019/05/30/测试/Jmeter测试脚本编写/","excerpt":"","text":"一、简介 Apache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。 它可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、数据库、FTP 服务器， 等等。 那么jmeter脚本怎么编写？ jmeter其实不需要自己添加脚本，配置一些东西就可以测试了！！！ 二、详细步骤1、先去apache官网下载jmeter，然后打开进入bin目录，点击jmeter.bat 2、点击之后会看到一个黑色的窗口（这个窗口不能关），还有一个jmeter工作窗口 3、右键测试计划，新建线程组 4、右键线程组，新建一个http请求 5、建好http请求之后，要把必要的参数填写上去（我的服务器都是自己的，根据你自己的填） 6、执行接口调用 7、执行完了怎么看结果呢？要先右键线程组，添加一个查看结果树 8、点击结果树就可以看到结果了 推荐阅读：Spring Security系列教程","categories":[{"name":"测试","slug":"测试","permalink":"https://blog.ffspace.cn/categories/测试/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://blog.ffspace.cn/tags/测试/"}]},{"title":"Spring Security常见问题解决方案","slug":"Spring Security常见问题解决方案","date":"2019-05-23T14:00:00.000Z","updated":"2020-11-02T02:24:16.704Z","comments":true,"path":"2019/05/23/Spring Security常见问题解决方案/","link":"","permalink":"https://blog.ffspace.cn/2019/05/23/Spring Security常见问题解决方案/","excerpt":"","text":"1、Spring Security 登录验证时候，表单name必须为username全小写。如果不一致会导致UserDetailsService的loadUserByUsername参数为空。2、不管是用户名不存在、密码错误等抛出的异常都是org.springframework.security.authentication.BadCredentialsException: Bad credentials。方案一：（来自网络）1.既然系统是捕获UsernameNotFoundException类型的异常后再抛出新的BadCredentialsException异常，那么我们干脆就不抛出UsernameNotFoundException异常。 我们模仿UsernameNotFoundException，创建自己的MyUsernameNotFoundException异常类。 2.在MyUserDetailsService类的loadUserByUsername方法抛出我们自己定义的MyUsernameNotFoundException异常。 方案二：在MyUserDetailsService类的loadUserByUsername方法直接抛出BadCredentialsException异常，这样就不需要创建自己的MyUsernameNotFoundException异常类。 好了，这样在页面通过[[${session.SPRING_SECURITY_LAST_EXCEPTION.message}]]，就能显示我们自定义的异常信息了。 3、跳转到/user页面时候出现org.springframework.security.access.AccessDeniedException: Access is deniedWebSecurityConfig代码 12345678910111213141516171819@Overrideprotected void configure(HttpSecurity http) throws Exception&#123; http.authorizeRequests() .antMatchers(&quot;/&quot;,&quot;/index&quot;).permitAll() // permitAll被允许访问 .antMatchers(&quot;/user/**&quot;).hasRole(&quot;USER&quot;)// 指定所有user页面需要USER角色才能访问 .and() .formLogin().loginPage(&quot;/login&quot;).defaultSuccessUrl(&quot;/user&quot;) .and() .logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/login&quot;);&#125; 解决方案：代码中我们设置了仅能USER访问。但是通过debug调试发现。在Security底层时候会自动加上ROLE_USER来进行角色校验。因此在数据库的字段必须加上ROLE_前缀","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.ffspace.cn/categories/后端/"},{"name":"Spring Security","slug":"后端/Spring-Security","permalink":"https://blog.ffspace.cn/categories/后端/Spring-Security/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://blog.ffspace.cn/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://blog.ffspace.cn/tags/Spring-Security/"}]},{"title":"Spring Security教程(五)--- 实现QQ授权登录","slug":"Spring-Security-教程（五）---实现QQ授权登录","date":"2019-05-22T14:40:00.000Z","updated":"2020-11-02T02:24:16.706Z","comments":true,"path":"2019/05/22/Spring-Security-教程（五）---实现QQ授权登录/","link":"","permalink":"https://blog.ffspace.cn/2019/05/22/Spring-Security-教程（五）---实现QQ授权登录/","excerpt":"","text":"一、准备1.1 先在QQ互联申请成为开发者，并创建应用申请APPId 和AppKey。1.2 查看官方接入流程文档。 以下是自己申请后的密钥，贡献出来方便各位测试 APP ID：101364240APP Key：ef27b7a6ca651a3609dd47f21e385955回调地址：http://127.0.0.1/login/qq 项目代码：https://github.com/Bootcap/spring-security-study-session 二、开发步骤前提，在上篇Spring Security (四) - 权限动态修改 的 pom.xml 基础上加入(或直接查看源码)1234&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt; &lt;artifactId&gt;jersey-media-json-jackson&lt;/artifactId&gt;&lt;/dependency&gt; 2.1 首先自定义QQAuthenticationFilter过滤器继承AbstractAuthenticationProcessingFilter类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.bootcap.session.security.filter;/** * QQ认证过滤器 * 2018-12-18 10:57 */public class QQAuthenticationFilter extends AbstractAuthenticationProcessingFilter &#123; /** * response_type 返回类型 */ private final static String RESPONSE_TYPE = &quot;code&quot;; /** * grant_type 由腾讯提供 */ private final static String GRANT_TYPE = &quot;authorization_code&quot;; /** * client_id 由腾讯提供(即AppId) */ static final String CLIENT_ID = &quot;101364240&quot;; /** * client_secret 由腾讯提供(即App Key) */ private final static String CLIENT_SECRET = &quot;ef27b7a6ca651a3609dd47f21e385955&quot;; /** * redirect_uri 腾讯回调地址 */ private final static String REDIRECT_URI = &quot;http://127.0.0.1/login/qq&quot;; /** * 获取 access_token_url 的 API */ private final static String ACCESS_TOKEN_URL = &quot;https://graph.qq.com/oauth2.0/token&quot;; /** * 获取 OpenID url地址 */ private final static String OPENID_URL = &quot;https://graph.qq.com/oauth2.0/me?access_token=%s&quot;; /** * 获取 token 的地址拼接 */ private final static String TOKEN_ACCESS_API = &quot;%s?grant_type=%s&amp;client_id=%s&amp;client_secret=%s&amp;code=%s&amp;redirect_uri=%s&quot;; public QQAuthenticationFilter(String defaultFilterProcessesUrl)&#123; super(new AntPathRequestMatcher(defaultFilterProcessesUrl, &quot;GET&quot;)); &#125; @Override public Authentication attemptAuthentication(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws AuthenticationException, IOException, ServletException &#123; UsernamePasswordAuthenticationToken authenticationToken = null; String code = httpServletRequest.getParameter(RESPONSE_TYPE);// System.out.println(&quot;输出response_type:&quot; + code); String accessTokenURL = String.format(TOKEN_ACCESS_API,ACCESS_TOKEN_URL,GRANT_TYPE,CLIENT_ID,CLIENT_SECRET,code,REDIRECT_URI);// System.out.println(&quot;accessTokenURL:&quot; +accessTokenURL); QQAccessToken qqAccessToken = getQQAccessToken(accessTokenURL); if (null != qqAccessToken)&#123; String openId = getOpenId(qqAccessToken.getAccessToken());// System.out.println(&quot;输出openId:&quot; + openId); if (null != openId)&#123; authenticationToken = new UsernamePasswordAuthenticationToken(qqAccessToken.getAccessToken(),openId); &#125; &#125; // 返回验证结果 return this.getAuthenticationManager().authenticate(authenticationToken); &#125; /** * 开始请求获取QQToken * @return */ private QQAccessToken getQQAccessToken(String accessTokenURL)&#123; Assert.notNull(accessTokenURL,&quot;accessTokenURL不能为空&quot;); RestTemplate template = new RestTemplate(); QQAccessToken qqAccessToken = new QQAccessToken(); String[] results = template.getForObject(accessTokenURL, String.class).split(&quot;&amp;&quot;); if (results.length == 3)&#123; String accessToken = results[0].replace(&quot;access_token=&quot;, &quot;&quot;); Integer expiresIn = Integer.valueOf(results[1].replace(&quot;expires_in=&quot;, &quot;&quot;)); String refreshToken = results[2].replace(&quot;refresh_token=&quot;, &quot;&quot;); qqAccessToken.setAccessToken(accessToken); qqAccessToken.setExpiresIn(expiresIn); qqAccessToken.setRefreshToken(refreshToken); &#125; return qqAccessToken; &#125; /** * 获取用户的唯一OpenId * @return */ private String getOpenId(String accessToken)&#123; RestTemplate template = new RestTemplate(); String openIdResult = template.getForObject(String.format(OPENID_URL,accessToken), String.class); Pattern pattern = Pattern.compile(&quot;\\&quot;openid\\&quot;:\\&quot;(.*)\\&quot;&quot;); Matcher matcher = pattern.matcher(openIdResult); while (matcher.find())&#123; return matcher.group(1); &#125; return null; &#125;&#125; 为什么要继承AbstractAuthenticationProcessingFilter类，请前往Spring Security（二） - 基于数据库实现校验的流程图。 2.2 创建QQAuthenticationManager通过accessToken和openId获取基本信息，并生成新的Authentication认证对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.bootcap.session.security.manager;/** * 管理授权类 * 2018-12-18 14:47 */public class QQAuthenticatioManager implements AuthenticationManager &#123; private static final List&lt;GrantedAuthority&gt; AUTHORITIES = new ArrayList&lt;&gt;(); public QQAuthenticatioManager()&#123;&#125; /** * 获取用户信息 */ private final static String USER_INFO_URL = &quot;https://graph.qq.com/user/get_user_info?access_token=%s&amp;oauth_consumer_key=%s&amp;openid=%s&quot;; /** * client_id 由腾讯提供(即AppId) */ static final String CLIENT_ID = &quot;101364240&quot;; static &#123; AUTHORITIES.add(new SimpleGrantedAuthority(&quot;ROLE_USER&quot;)); &#125; @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; QQUserInfo qqUserInfo = null; if (authentication.getName() != null &amp;&amp; authentication.getCredentials() != null)&#123; qqUserInfo = getUserInfo(authentication.getName(), (String) authentication.getCredentials()); &#125;// System.out.println(&quot;输出用户信息：&quot; +qqUserInfo.toString()); return new UsernamePasswordAuthenticationToken(qqUserInfo,null,AUTHORITIES); &#125; /** * 获取QQ授权后的基本信息 * @param accessToken * @param openId * @return */ private QQUserInfo getUserInfo(String accessToken, String openId) &#123; String url = String.format(USER_INFO_URL,accessToken,CLIENT_ID,openId); RestTemplate template = new RestTemplate(); String userInfoResult = template.getForObject(url, String.class); QQUserInfo qqUserInfo = jsonToObject(userInfoResult, QQUserInfo.class); return qqUserInfo; &#125; private &lt;T&gt; T jsonToObject(String json,Class&lt;T&gt; targetClass)&#123; ObjectMapper objectMapper = new ObjectMapper(); objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); try &#123; return objectMapper.readValue(json,targetClass); &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 为什么要实现AuthenticationManager类?因为在AbstractAuthenticationProcessingFilter.doFilter()方法中调用了this.attemptAuthentication(request, response) 中实现的方法（即2.1中我们自定义的Filter类的实现方法）。因此在我们自定义类中中调用了 this.getAuthenticationManager().authenticate(authRequest)，所以需要实现该类。 2.3 在WebSecurityConfig类中添加自定义过滤器123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.bootcap.session.security.configuration;/** * WebSecurityConfig 配置文件 * 2018-12-10 11:03 */@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/user/**&quot;).hasRole(&quot;USER&quot;) .and() .formLogin().loginPage(&quot;/login&quot;).defaultSuccessUrl(&quot;/user&quot;) .and() .logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/login&quot;); // 在 UsernamePasswordAuthenticationFilter 前添加 QQAuthenticationFilter http.addFilterAt(qqAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() // 在内存中进行身份验证 .passwordEncoder(new BCryptPasswordEncoder()) .withUser(&quot;user&quot;) .password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)) .roles(&quot;USER&quot;); &#125; /** * 自定义 QQ登录 过滤器 */ private QQAuthenticationFilter qqAuthenticationFilter()&#123; QQAuthenticationFilter authenticationFilter = new QQAuthenticationFilter(&quot;/login/qq&quot;); SimpleUrlAuthenticationSuccessHandler simpleUrlAuthenticationSuccessHandler = new SimpleUrlAuthenticationSuccessHandler(); simpleUrlAuthenticationSuccessHandler.setAlwaysUseDefaultTargetUrl(true); simpleUrlAuthenticationSuccessHandler.setDefaultTargetUrl(&quot;/user&quot;); authenticationFilter.setAuthenticationSuccessHandler(simpleUrlAuthenticationSuccessHandler); authenticationFilter.setAuthenticationManager(new QQAuthenticatioManager()); return authenticationFilter; &#125;&#125; 2.4 修改Controller和页面2.4.1 Controller配置详见【项目代码spring-security-05】2.4.2 login.html页面1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录页面&lt;/h1&gt;&lt;div th:if=&quot;$&#123;param.error&#125;&quot;&gt; 用户名或密码不正确&lt;/div&gt;&lt;div th:if=&quot;$&#123;param.logout&#125;&quot;&gt; 你已经退出登录&lt;/div&gt;&lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt; &lt;div&gt;&lt;label&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;label&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码: &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;/label&gt;&lt;/div&gt; &lt;br/&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt; &lt;br/&gt; &lt;a href=&quot;https://graph.qq.com/oauth2.0/authorize?response_type=code&amp;client_id=101364240&amp;redirect_uri=http://127.0.0.1/login/qq&amp;state=test&quot;&gt;&lt;img style=&quot;padding-top: 5px&quot; src=&quot;/static/imgs/qqLogin.png&quot; /&gt;&lt;/a&gt; &lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.4.3 user.html页面12345678910111213141516171819202122&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;用户界面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot; style=&quot;margin-top: 60px&quot;&gt; &lt;div style=&quot;text-align: center; margin-top: 10%&quot;&gt; &lt;img th:src=&quot;$&#123;avatar&#125;&quot; th:alt=&quot;$&#123;avatar&#125;&quot; /&gt; &lt;p th:text=&quot;$&#123;username&#125;&quot; style=&quot;margin-top: 25px; font-size: 20px; color: crimson&quot;&gt;&lt;/p&gt; &lt;form th:action=&quot;@&#123;/logout&#125;&quot; method=&quot;post&quot;&gt; &lt;button style=&quot;margin-top: 20px&quot;&gt;退出登录&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.5 补充示例中需要用到的实体类2.5.1 QQAccessToken.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.bootcap.session.security.entity;/** * 2018-12-18 11:47 */public class QQAccessToken &#123; /** * 授权accessToken */ private String accessToken; /** * 该access token的有效期，单位为秒。 */ private Integer expiresIn; /** * 在授权自动续期步骤中，获取新的Access_Token时需要提供的参数。 */ private String refreshToken; public String getAccessToken() &#123; return accessToken; &#125; public void setAccessToken(String accessToken) &#123; this.accessToken = accessToken; &#125; public int getExpiresIn() &#123; return expiresIn; &#125; public void setExpiresIn(Integer expiresIn) &#123; this.expiresIn = expiresIn; &#125; public String getRefreshToken() &#123; return refreshToken; &#125; public void setRefreshToken(String refreshToken) &#123; this.refreshToken = refreshToken; &#125; @Override public String toString() &#123; return &quot;QQAccessToken&#123;&quot; + &quot;accessToken=&apos;&quot; + accessToken + &apos;\\&apos;&apos; + &quot;, expiresIn=&quot; + expiresIn + &quot;, refreshToken=&apos;&quot; + refreshToken + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 2.5.2 QQUserInfo.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.bootcap.session.security.entity;/** * qq信息实体 * 2018-12-18 15:34 */public class QQUserInfo &#123; /** * 昵称 */ private String nickname; /** * 性别 */ private String gender; /** * QQ头像 */ private String figureurl_qq_1; public String getNickname() &#123; return nickname; &#125; public void setNickname(String nickname) &#123; this.nickname = nickname; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getFigureurl_qq_1() &#123; return figureurl_qq_1; &#125; public void setFigureurl_qq_1(String figureurl_qq_1) &#123; this.figureurl_qq_1 = figureurl_qq_1; &#125; @Override public String toString() &#123; return &quot;QQUserInfo&#123;&quot; + &quot;nickname=&apos;&quot; + nickname + &apos;\\&apos;&apos; + &quot;, gender=&apos;&quot; + gender + &apos;\\&apos;&apos; + &quot;, figureurl_qq_1=&apos;&quot; + figureurl_qq_1 + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 三、测试3.1 启动项目并且浏览器访问:127.0.0.1/user，会自动跳转到登录页面【注意】：我们发现我们使用的静态资源qq登录的图片，不会显示,同时浏览器控制台报404，说图片未找到。【解决方法】：在configuration包下新建一个WebMvcConfig.java类设置我们静态资源的路径12345678910package com.bootcap.session.security.configuration;@Configurationpublic class WebMvcConfig extends WebMvcConfigurationSupport &#123; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;); &#125;&#125; 3.2 再次启动并访问页面，已经可以正常显示 3.3 使用qq登录","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.ffspace.cn/categories/后端/"},{"name":"Spring Security","slug":"后端/Spring-Security","permalink":"https://blog.ffspace.cn/categories/后端/Spring-Security/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://blog.ffspace.cn/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://blog.ffspace.cn/tags/Spring-Security/"}]},{"title":"Spring Security教程(四)--- 权限动态修改","slug":"Spring-Security-教程（四）---权限动态修改","date":"2019-05-22T14:30:00.000Z","updated":"2020-11-02T02:24:16.707Z","comments":true,"path":"2019/05/22/Spring-Security-教程（四）---权限动态修改/","link":"","permalink":"https://blog.ffspace.cn/2019/05/22/Spring-Security-教程（四）---权限动态修改/","excerpt":"","text":"前言本篇pom.xml与上篇文章 Spring Security 入门教程（三）- 基于登录认证记住我实例 相同。 项目代码：https://github.com/Bootcap/spring-security-study-session 一、新建VipController.java12345678910111213141516171819202122232425262728package com.bootcap.session.security.controller;/** * 动态权限修改Controller * 2018-12-15 14:16 */@Controller@ResponseBodypublic class VipController &#123; @RequestMapping(value = &quot;/vip/index&quot;,method = RequestMethod.GET) public String vipPage()&#123; return &quot;只有VIP用户可观看&quot;; &#125; @RequestMapping(value = &quot;/getVIP&quot;,method = RequestMethod.GET) public String getVip()&#123; // 获取认证信息 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); List&lt;GrantedAuthority&gt; update = new ArrayList&lt;&gt;(authentication.getAuthorities()); // 添加VIP授权 update.add(new SimpleGrantedAuthority(&quot;ROLE_VIP&quot;)); // 生成新的认证信息 Authentication newAuth = new UsernamePasswordAuthenticationToken(authentication.getPrincipal(), authentication.getCredentials(), update); SecurityContextHolder.getContext().setAuthentication(newAuth); return &quot;ok&quot;; &#125;&#125; 二、修改WebSecurityConfig.java123456789101112131415161718package com.bootcap.session.security.configuration;/** * 2018-12-10 11:03 */@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(&quot;/getVIP&quot;).permitAll() .antMatchers(&quot;/vip/index&quot;).hasRole(&quot;VIP&quot;); &#125;&#125; 三、启动测试3.1 假设当前你的权限只有 ROLE_USER的时候访问：localhost:8080/vip/index 时页面会提示403，同时控制台也会抛出“Access is denied 无权限”异常（提示：若没有异常可以在application.yml下修改：org.springframework.security: debug）。 3.2 开启另外窗口，访问：localhost:8080/getVIP 地址，返回了”ok”，再刷新页面即可正常访问；","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.ffspace.cn/categories/后端/"},{"name":"Spring Security","slug":"后端/Spring-Security","permalink":"https://blog.ffspace.cn/categories/后端/Spring-Security/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://blog.ffspace.cn/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://blog.ffspace.cn/tags/Spring-Security/"}]},{"title":"Spring Security教程(三) --- 基于登录认证记住我实例","slug":"Spring-Security-教程（三）---基于登录认证记住我实例","date":"2019-05-22T14:20:00.000Z","updated":"2020-11-02T02:24:16.705Z","comments":true,"path":"2019/05/22/Spring-Security-教程（三）---基于登录认证记住我实例/","link":"","permalink":"https://blog.ffspace.cn/2019/05/22/Spring-Security-教程（三）---基于登录认证记住我实例/","excerpt":"","text":"介绍本篇文章基于Spring Security 入门教程（一） - 简单的登录认证 基础上修改的记住我教程。 项目代码：https://github.com/Bootcap/spring-security-study-session 一、配置pom.xml文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;name&gt;spring-security-study-session&lt;/name&gt; &lt;groupId&gt;com.bootcap.session.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-study-session&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring Boot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 二、修改TemplateConfig.java类路径：src/java/com/bootcap/session/security/configuration/TemplateConfig.java12345678910@Configurationpublic class TemplateConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/index&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/login&quot;).setViewName(&quot;login&quot;); &#125;&#125; 三、修改WebSecurityConfig.java路径：src/java/com/bootcap/session/security/configuration/WebSecurityConfig.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.bootcap.session.security.configuration;/** * 2018-12-10 11:03 */@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override public void configure(WebSecurity web) throws Exception &#123; web.ignoring() .antMatchers(&quot;/js/**&quot;,&quot;/img/**&quot;); &#125; // 重点修改的方法 @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .loginPage(&quot;/login&quot;) .permitAll().defaultSuccessUrl(&quot;/&quot;) .and() .logout() .invalidateHttpSession(true) .clearAuthentication(true) .logoutRequestMatcher(new AntPathRequestMatcher(&quot;/logout&quot;)) .logoutSuccessUrl(&quot;/login?logout&quot;) .permitAll() .and() .rememberMe() .key(&quot;unique-and-secret&quot;) .rememberMeCookieName(&quot;rememberMeCookieName&quot;) // 设置cookie名称 .tokenValiditySeconds(24 * 60 * 60); // 设置令牌有效期，若不自定义：默认为2周 &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() // 在内存中进行身份验证 .passwordEncoder(new BCryptPasswordEncoder()) .withUser(&quot;user&quot;) .password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)) .roles(&quot;USER&quot;); &#125;&#125; 四、修改页面文件路径：src/resources/templates/ 4.1 修改login.html，在原基础上加上记住我复选框123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录页面&lt;/h1&gt;&lt;div th:if=&quot;$&#123;param.error&#125;&quot;&gt; 用户名或密码不正确&lt;/div&gt;&lt;div th:if=&quot;$&#123;param.logout&#125;&quot;&gt; 你已经退出登录&lt;/div&gt;&lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt; &lt;div&gt;&lt;label&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;label&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码: &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt; &lt;input id=&quot;remember-me&quot; name=&quot;remember-me&quot; type=&quot;checkbox&quot;/&gt; 记住我 &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt; &lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 4.2 修改index.html123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;/&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt; &lt;title&gt;Spring Security 登录认证记住我实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;h1&gt;Spring Security 登录认证记住我实例&lt;/h1&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt; &lt;span sec:authorize=&quot;isAuthenticated()&quot;&gt; | 登录用户: &lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt; | 角色: &lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt; | &lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;退出登录&lt;/a&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 五、启动Application.java运行项目5.1 项目启动完成后，浏览器访问：localhsot:8080，会自动跳到登录页面进行登录，并勾选记住我。 5.2 登录成功后会挑战到index.html页面，通过debug发现，spring security已经为我们分配了刚才命名的cookie。 5.3 为了验证是记住我登录，我们把JSESSIONID删除，并刷新页面，会发现又刚删除的JSESSIONID又产生了。而且Value值已经改变。","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.ffspace.cn/categories/后端/"},{"name":"Spring Security","slug":"后端/Spring-Security","permalink":"https://blog.ffspace.cn/categories/后端/Spring-Security/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://blog.ffspace.cn/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://blog.ffspace.cn/tags/Spring-Security/"}]},{"title":"Spring Security教程(二) --- 基于数据库信息进行验证","slug":"Spring-Security-教程（二）---基于数据库信息进行验证","date":"2019-05-22T14:10:00.000Z","updated":"2020-11-02T02:24:16.706Z","comments":true,"path":"2019/05/22/Spring-Security-教程（二）---基于数据库信息进行验证/","link":"","permalink":"https://blog.ffspace.cn/2019/05/22/Spring-Security-教程（二）---基于数据库信息进行验证/","excerpt":"","text":"介绍本篇文章将讲解使用Spring Security + Mybatis + Mysql数据库实现简单的登录校验，以及密码加密校验。 项目代码：https://github.com/Bootcap/spring-security-study-session 一、创建数据库和需要的表结构1.1 创建数据库12create database user;use user; 1.2 创建user_info表，执行sql脚本生成1234567891011121314151617SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;DROP TABLE IF EXISTS `user_info`;CREATE TABLE `user_info` ( `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;主键，自增&apos;, `user_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT &apos;用户名&apos;, `user_password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT &apos;用户密码&apos;, `user_roles` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT &apos;用户角色&apos;, PRIMARY KEY (`user_id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;INSERT INTO `user_info` VALUES (1, &apos;1&apos;, &apos;1&apos;, &apos;ROLE_USER&apos;);INSERT INTO `user_info` VALUES (2, &apos;user&apos;, &apos;123456&apos;, &apos;ROLE_USER&apos;);INSERT INTO `user_info` VALUES (3, &apos;user2&apos;, &apos;$2a$10$RHWoRd6hPXffZemAD7Gp6ehhf929etTHVGm7JGBeJTNQIgVURnSb.&apos;, &apos;ROLE_USER&apos;);SET FOREIGN_KEY_CHECKS = 1; 二、修改配置2.1 修改pom.xml在上篇文章所需jar包的基础上引入mysql和mybatis相关包。查看完整pom.xml12345678910&lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 修改application.yml在上篇文章resources/application.yml的基础上增加”数据源配置”和”日志配置”1234567891011121314151617181920212223242526# 端口号server: port: 8080spring: # thymeleaf配置 thymeleaf: enabled: true encoding: UTF-8 mode: HTML servlet: content-type: text/html prefix: classpath:/templates/ suffix: .html # 数据源配置 datasource: url: jdbc:mysql://127.0.0.1:3306/user?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false # 修改为自己数据库所在ip地址 driver-class-name: com.mysql.jdbc.Driver username: root # 默认用户名，修改为自己的数据库用户名 password: # 填写自己的密码logging: level: root: INFO org.springframework.web: INFO org.springframework.security: INFO 三、创建CRUD操作的相关类经过上面的配置修改后，还需要有一套完整的CRUD操作，本篇文章仅介绍注册和登录校验，因此只有注册和登录校验操作。 3.1 创建数据库实体类（UserInfo.java） 路径：com/bootcap/session/security/entity/UserInfo.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.bootcap.session.security.entity;/** * 数据库实体类 * 2018-12-10 16:21 */public class UserInfo &#123; private Integer id; private String userName; private String password; private String roles; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getRoles() &#123; return roles; &#125; public void setRoles(String roles) &#123; this.roles = roles; &#125; @Override public String toString() &#123; return &quot;UserInfo&#123;&quot; + &quot;id=&quot; + id + &quot;, userName=&apos;&quot; + userName + &apos;\\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\\&apos;&apos; + &quot;, roles=&apos;&quot; + roles + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 3.2 创建映射文件（UserInfoMapper.java） 【提示】: 本文直接使用mybatis的注解形式进行sql编写 路径：com/bootcap/session/security/mapper/UserInfoMapper.java12345678910111213141516171819202122232425262728package com.bootcap.session.security.mapper;import com.bootcap.session.security.entity.UserInfo;import org.apache.ibatis.annotations.*;/** * UserInfo映射类 * 2018-12-10 16:26 * 两个注解区别，网络上说是使用该@Repository注解需要配置xml映射文件，但是小编更改后并未出现异常。 */// @Mapper@Repositorypublic interface UserInfoMapper &#123; /** * 新增 * @param userInfo * @return */ @Insert(&quot;insert into user_info(user_name,user_password,user_roles) values(#&#123;userName&#125;,#&#123;password&#125;, #&#123;roles&#125;)&quot;) int insert(UserInfo userInfo); /** * 查询 */ @Select(&quot;select user_name as userName,user_password as password,user_roles as roles,user_id as id from user_info where user_name = #&#123;userName&#125;&quot;) UserInfo selectByUserName(@Param(&quot;userName&quot;) String userName);&#125; 3.3 创建业务层类（UserInfoService.java）路径：com/bootcap/session/security/mapper/UserInfoService.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.bootcap.session.security.service;import com.bootcap.session.security.constant.RolesContant;import com.bootcap.session.security.entity.UserInfo;import com.bootcap.session.security.mapper.UserInfoMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.stereotype.Service;/** * service业务层 * 2018-12-10 16:37 */@Servicepublic class UserInfoService &#123; @Autowired UserInfoMapper userInfoMapper; /** * 新增用户 * @param userInfo * @return */ public boolean insert(UserInfo userInfo) &#123; UserInfo userInfo1 = userInfoMapper.selectByUserName(userInfo.getUserName()); if (userInfo1 != null)&#123; return false; &#125; userInfo.setRoles(RolesContant.USER); // 加密保存密码到数据库 userInfo.setPassword(new BCryptPasswordEncoder().encode(userInfo.getPassword())); int result = userInfoMapper.insert(userInfo); return result == 1; &#125; /** * 查询用户 * @param username * @return */ public UserInfo selectUserInfo(String username) &#123; return userInfoMapper.selectByUserName(username); &#125;&#125; 【说明】: 由于业务代码使用了常量类，因此需要创建一个枚举类RolesContant.java，内容如下: public static final String USER = “ROLE_USER”; 3.4 创建控制层（UserController.java）路径：com/bootcap/session/security/mapper/UserController.java1234567891011121314151617181920212223242526package com.bootcap.session.security.controller;/** * 2018-12-10 17:02 */@Controllerpublic class UserController &#123; @Autowired UserInfoService userInfoService; @PostMapping(&quot;/register&quot;) public String doRegister(UserInfo userInfo)&#123; boolean insert = userInfoService.insert(userInfo); if (insert)&#123; return &quot;redirect:sign?success&quot;; &#125; return &quot;redirect:sign?error&quot;; &#125; @GetMapping(&quot;/user&quot;) public String user(@AuthenticationPrincipal Principal principal, Model model)&#123; model.addAttribute(&quot;username&quot;, principal.getName()); return &quot;user/user&quot;; &#125;&#125; 四、配置Spring Security获取数据库数据进行校验 【说明】: 从流程图中我们可以得到，Spring Security最终使用UserDetailsService.loadUserByUsername()方法连接数据库获取数据并返回给校验类进行校验，因此我们需要在项目中实现该接口。 4.1 创建MyUserDetailsService.java类并实现UsesrDetailsService12345678910111213141516171819202122232425262728293031323334353637383940package com.bootcap.session.security.configuration;import com.bootcap.session.security.service.UserInfoService;import com.bootcap.session.security.entity.UserInfo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.List;/** * 自定义登录校验Service * 2018-12-10 17:23 */@Servicepublic class MyUserDetailsService implements UserDetailsService &#123; @Autowired UserInfoService userInfoService; @Override public UserDetails loadUserByUsername(String userName) throws UsernameNotFoundException &#123; UserInfo userInfo = userInfoService.selectUserInfo(userName); if (userInfo == null) &#123; throw new UsernameNotFoundException(&quot;用户不存在&quot;); // 若不存在抛出用户不存在异常 &#125; // 权限字符串转化 List&lt;SimpleGrantedAuthority&gt; simpleGrantedAuthorities = new ArrayList&lt;&gt;(); String[] roles = userInfo.getRoles().split(&quot;,&quot;);// 获取后的Roles必须有ROLE_前缀，否则会抛Access is denied无权限异常 for (String role : roles) &#123; simpleGrantedAuthorities.add(new SimpleGrantedAuthority(role)); &#125; // 交给security进行验证并返回 return new User(userInfo.getUserName(), userInfo.getPassword(), simpleGrantedAuthorities); &#125;&#125; 4.2 修改WebSecurityConfig.java调用123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.bootcap.session.security.configuration;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;/** * 2018-12-10 11:03 */@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired MyUserDetailsService myUserDetailsService; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(&quot;/&quot;,&quot;/index&quot;).permitAll() // permitAll被允许访问 .antMatchers(&quot;/user/**&quot;).hasRole(&quot;USER&quot;)// 指定所有user页面需要USER角色才能访问 .and() .formLogin().loginPage(&quot;/login&quot;).defaultSuccessUrl(&quot;/user&quot;) .and() .logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/login&quot;); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;// auth.inMemoryAuthentication() // 在内存中进行身份验证// .passwordEncoder(new BCryptPasswordEncoder())// .withUser(&quot;user&quot;)// .password(new BCryptPasswordEncoder().encode(&quot;123456&quot;))// .roles(&quot;USER&quot;);// 修改的地方，将上篇文章的内存验证改为获取数据库，并使用了密码加密 auth.userDetailsService(myUserDetailsService).passwordEncoder(new BCryptPasswordEncoder()); &#125;&#125; 扩展：对密码进行加密1、修改WebSecurityConfig.configure()方法1auth.userDetailsService(myUserDetailsService).passwordEncoder(new BCryptPasswordEncoder()); 2、在UserInfoService.insert()方法对password字段进行加密存储12345678910public boolean insert(UserInfo userInfo) &#123; UserInfo userInfo1 = userInfoMapper.selectByUserName(userInfo.getUserName()); if (userInfo1 != null)&#123; return false; &#125; userInfo.setRoles(RolesContant.USER); userInfo.setPassword(new BCryptPasswordEncoder().encode(userInfo.getPassword())); int result = userInfoMapper.insert(userInfo); return result == 1; &#125; 4.3 修改TemplateConfig.java（用于新增的注册页面）12345678910111213@Configurationpublic class TemplateConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/index&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/hello&quot;).setViewName(&quot;hello&quot;); registry.addViewController(&quot;/login&quot;).setViewName(&quot;login&quot;); // 新增注册页面 registry.addViewController(&quot;/sign&quot;).setViewName(&quot;register&quot;); &#125;&#125; 4.4 上述配置完成后，我们需要增加和修改几个页面用于测试4.4.1 修改login.html（增加跳转到注册连接）123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录页面&lt;/h1&gt;&lt;div th:if=&quot;$&#123;param.error&#125;&quot;&gt; 用户名或密码不正确&lt;/div&gt;&lt;div th:if=&quot;$&#123;param.logout&#125;&quot;&gt; 你已经退出登录&lt;/div&gt;&lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt; &lt;div&gt;&lt;label&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;label&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码: &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt; &lt;a th:href=&quot;@&#123;/sign&#125;&quot;&gt;注册&lt;/a&gt; &lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 4.4.2 新增register.html注册页面123456789101112131415161718192021222324252627282930313233&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;panel-body&quot;&gt; &lt;h1&gt;注册页面&lt;/h1&gt; &lt;form th:action=&quot;@&#123;/register&#125;&quot; method=&quot;post&quot;&gt; &lt;div&gt; 账号: &lt;input type=&quot;text&quot; name=&quot;userName&quot; id=&quot;username&quot; placeholder=&quot;账号&quot;&gt; &lt;/div&gt; &lt;div&gt; 密码: &lt;input type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;密码&quot;&gt; &lt;/div&gt; &lt;br&gt; &lt;div th:if=&quot;$&#123;param.error&#125;&quot;&gt; &lt;p&gt;注册失败，账号已存在！&lt;/p&gt; &lt;/div&gt; &lt;div th:if=&quot;$&#123;param.success&#125;&quot;&gt; &lt;p&gt;注册成功，可以登录了！&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-block&quot;&gt;注册&lt;/button&gt; &lt;a href=&quot;/login&quot;&gt;返回登录页面&lt;/a&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4.4.3 新增user.html（用于登录后跳转的页面）路径：templates/user/user.html123456789101112131415161718192021&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;用户界面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot; style=&quot;margin-top: 60px&quot;&gt; &lt;div style=&quot;text-align: center; margin-top: 10%&quot;&gt; &lt;p th:text=&quot;$&#123;username&#125;&quot; style=&quot;margin-top: 25px; font-size: 20px; color: crimson&quot;&gt;&lt;/p&gt; &lt;form th:action=&quot;@&#123;/logout&#125;&quot; method=&quot;post&quot;&gt; &lt;button style=&quot;margin-top: 20px&quot;&gt;退出登录&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 五、启动运行至此，基本修改已经完毕，这时候可以启动Application.java启动运行了？答案：不能！！！ 【提示】: 本项目的启动类是在app包下，因此我们配置的mapper映射文件的@Repository注解为mybatis的注解，所以boot不会自动注入，因此需要加入@MapperScan(basePackages = “com.bootcap.session.security.mapper”)1234567891011121314package com.bootcap.session.security.app;/** * 启动类 * 2018-12-10 11:03 */@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;com.bootcap.session.security&quot;&#125;)@MapperScan(basePackages = &quot;com.bootcap.session.security.mapper&quot;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class,args); &#125;&#125; 六、测试结果6.1 项目启动后，浏览器访问：localhost:8080/user,会发现直接跳转到登录页 6.2 目前我们没有账号，点击注册按钮进行注册，注册好后。我们使用注册的账号进行登录 ，可以正常进入user页面 七、扩展篇 - 自定义Filter过滤器7.1 创建两个自定义Filter过滤器（BeforeFilter.java和BeforeFilter.java）路径：com/bootcap/session/security/filter1234567891011121314package com.bootcap.session.security.filter;/** * BeforeFilter * 2018-12-12 10:44 */public class BeforeFilter extends GenericFilterBean &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;在 UsernamePasswordAuthenticationFilter 前添加 BeforeLoginFilter&quot;); // 继续调用 Filter 链 filterChain.doFilter(servletRequest, servletResponse); &#125;&#125; 123456789101112package com.bootcap.session.security.filter;/** * AfterCsrfFilter * 2018-12-12 10:46 */public class AfterCsrfFilter extends GenericFilterBean &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;在 CsrfFilter 后添加 AfterCsrfFilter&quot;); filterChain.doFilter(servletRequest,servletResponse); &#125;&#125; 7.2 在WebSecurityConfig.configure()方法中加入调用123456789@Override protected void configure(HttpSecurity http) throws Exception &#123; ... 省略部分代码 ... // 在 UsernamePasswordAuthenticationFilter 前添加 BeforeLoginFilter http.addFilterBefore(new BeforeFilter(), UsernamePasswordAuthenticationFilter.class); // 在 CsrfFilter 后添加 AfterCsrfFilter http.addFilterAfter(new AfterCsrfFilter(), CsrfFilter.class); &#125; 7.3 运行程序并访问任意可访问页面，我们能够的到两个过滤器的执行顺序12345672018-12-12 10:49:34.607 INFO 1060 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring FrameworkServlet &apos;dispatcherServlet&apos;2018-12-12 10:49:34.607 INFO 1060 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : FrameworkServlet &apos;dispatcherServlet&apos;: initialization started2018-12-12 10:49:34.611 INFO 1060 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : FrameworkServlet &apos;dispatcherServlet&apos;: initialization completed in 4 ms在 CsrfFilter 后添加 AfterCsrfFilter在 UsernamePasswordAuthenticationFilter 前添加 BeforeLoginFilter在 CsrfFilter 后添加 AfterCsrfFilter在 UsernamePasswordAuthenticationFilter 前添加 BeforeLoginFilter","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.ffspace.cn/categories/后端/"},{"name":"Spring Security","slug":"后端/Spring-Security","permalink":"https://blog.ffspace.cn/categories/后端/Spring-Security/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://blog.ffspace.cn/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://blog.ffspace.cn/tags/Spring-Security/"}]},{"title":"Spring Security教程(一) --- 简单的登录认证","slug":"Spring-Security-教程（一）---简单的登录认证","date":"2019-05-22T14:00:00.000Z","updated":"2020-11-02T02:24:16.705Z","comments":true,"path":"2019/05/22/Spring-Security-教程（一）---简单的登录认证/","link":"","permalink":"https://blog.ffspace.cn/2019/05/22/Spring-Security-教程（一）---简单的登录认证/","excerpt":"","text":"一、Spring Security 概述Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准，也是一个专注于向Java应用程序提供身份验证和授权的框架。连接：Spring Security 项目代码：https://github.com/Bootcap/spring-security-study-session 二、环境要求 JDK ≥1.7 Maven 3.0+ IntelliJ IDEA/eclipse 【提示】: 本文以 IDEA 和 maven 以及Spring Boot 2.0 为例进行教程 三、使用Maven进行构建在pom.xml文件中引入相关的jar包（不含security）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;name&gt;spring-security-study-session&lt;/name&gt; &lt;groupId&gt;com.bootcap.session.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-study-session&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 在项目的src/main/resources下进行配置1234567891011121314# 端口号server: port: 8080spring: # thymeleaf配置 thymeleaf: enabled: true encoding: UTF-8 mode: HTML servlet: content-type: text/html prefix: classpath:/templates/ suffix: .html 四、创建一个不受保护的web页面Web页面包含两个简单的视图：index主页和“hello”页面，都定义在Thymeleaf模板中。 4.1 Index页面路径：src/main/resources/templates/index.html1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Spring Security Index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Index Page&lt;/h1&gt; &lt;a th:href=&quot;@&#123;/hello&#125;&quot;&gt;点击前往hello页面&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 【注意】: 使用thymeleaf时需要在标签后面加入xmlns=”http://www.w3.org/1999/xhtml&quot; xmlns:th=”http://www.thymeleaf.org&quot; 属性，才能被编译器解析为thymeleaf模板 4.2 Hello页面路径：src/main/resources/templates/hello.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello Spring Security&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 从上面index.html可以看到包含了一个”/hello”连接点击跳转到hello.html页面的简单流程 五、配置Spring MVC视图控制器由于Web应用程序基于Spring MVC。 因此，需要配置视图控制器来暴露这些模板。路径：src/main/java/com/bootcap/session/security/configuration/TemplateConfig.java123456789101112131415161718package com.bootcap.session.security.configuration;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class TemplateConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/index&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/hello&quot;).setViewName(&quot;hello&quot;); registry.addViewController(&quot;/login&quot;).setViewName(&quot;login&quot;); &#125;&#125; 六、配置Spring Boot启动类6.1 到了这一步，我们需要将项目运行查看是否无异常，才进行下一步操作，因此需要配置spring boot启动类路径：src/main/java/com/bootcap/session/security/app/Application.java12345678910111213package com.bootcap.session.security.app;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;com.bootcap.session.security&quot;&#125;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class,args); &#125;&#125; 6.2 运行main方法，并在浏览器地址栏输入：http://localhost:8080/ 如果看到index.html页面，说明已经成功运行 6.3 点击跳转到hello页面链接，无需任何认证即可进行跳转 【小窍门】: 为什么要使用@ComponentScan注解： 如果你的其他包都在使用了@SpringBootApplication注解的main方法所在的包及其下级包，则SpringBoot会自动帮你把其他包都扫描。 如果你有一些bean所在的包，不在@SpringBootApplication注解main方法的包及其下级包，那么你需要手动加上@ComponentScan注解并指定要寻找的bean所在的包路径。（详见上述代码中package的不同之处） 七、引入并使用Spring Security在上述的两个视图中，我们希望在访问”/hello”时需要登录才能够进入Hello页面。此时我们可以通过Spring Security来实现。（如果Spring Security在类路径上，则Spring Boot会使用”Basic”认证自动保护所有HTTP请求，也可以自定义设置） 7.1 pom.xml加入Spring Security12345678&lt;dependencies&gt; ... &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; ...&lt;/dependencies&gt; 7.2 配置只有认证过的用户才能访问hello.html路径：src/main/java/com/bootcap/session/security/configuration/WebSecurityConfig.java123456789101112131415161718192021222324252627282930313233package com.bootcap.session.security.configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(&quot;/&quot;,&quot;/index&quot;).permitAll() // permitAll被允许访问 .anyRequest().authenticated() // 其余的请求需要认证后才可允许访问 .and() .formLogin() .loginPage(&quot;/login&quot;) .permitAll() .and() .logout() .permitAll(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() // 在内存中进行身份验证 .withUser(&quot;user&quot;) .password(&quot;password&quot;) .roles(&quot;USER&quot;); &#125;&#125; 【说明】: WebSecurityConfig类使用了@EnableWebSecurity注解，以启用Spring Security的Web安全支持。 configure(HttpSecurity)方法自定义有哪些url需要被认证，哪些不需要。当用户登录后将会被重定向请求到需要身份认证的页面（hello.html），否则在用户未登录的情况下将会跳转到登录页面 configure(AuthenticationManagerBuilder)方法用于设置认证的条件保存于内存中，用户名为“user”，密码为“123456”，角色为User。同时该方法也可以修改认证方式为jdbc进行认证 【注意】: 使用了Spring Boot 2.0以上的Security会存在There is no PasswordEncoder mapped for the id “null”异常，解决方案见底部“常见问题” 7.3 创建登录页面（认证时需要用到）路径：src/main/resources/templates/login.html1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:if=&quot;$&#123;param.error&#125;&quot;&gt; 用户名或密码不正确&lt;/div&gt;&lt;div th:if=&quot;$&#123;param.logout&#125;&quot;&gt; 你已经退出登录&lt;/div&gt;&lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt; &lt;div&gt;&lt;label&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;label&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码: &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;&lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 【说明】: 该登录页面会将用户名和密码以表单形式提交到”/login”。 在Spring Security提供了一个拦截请求并验证的过滤器，在用户未通过认证的情况下会重定向到”/login?error”，并且显示相应的错误信息。注销成功后，Spring Security会将地址重定向到”/login?logout”，我们即可在页面中看到相应的登出信息 7.4 修改hello.html在认证成功后跳转到hello.html页面，我们希望能够看到登录的用户名，同时允许用户退出登录,因此我们需要修改hello.html页面 路径：src/main/resources/templates/hello.html12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 th:inline=&quot;text&quot;&gt;Hello [[$&#123;#httpServletRequest.remoteUser&#125;]]&lt;/h1&gt; &lt;form th:action=&quot;@&#123;/logout&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;退出登录&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 【说明】: 我们在hello.html页面中使用了HttpServletRequest#getRemoteUser()的thymeleaf集成来显示用户名。 页面中退出登录表单会将请求提交到”/logout”，成功注销后程序会重定向到”/login?logout”。 7.5 启动应用程序通过文章刚开始的 【配置Spring Boot启动类】模块启动应用程序，这里不再过多介绍。 八、测试8.1 应用启动后, 在浏览器中访问 http://localhost:8080. 就能访问到Index页面 8.2 点击跳转到hello.html页面，会发现没有认证不允许进入，程序自动跳转到登录页 8.3 我们输入错误的信息会提示用户名或密码不正确，同时地址栏的地址也变成了”/login?error” 8.4 下面我们输入正确的账号登录（用户名：user，密码：123456）我们会发现在控制台出现了异常（解决方案：详见底部【常见问题】） 8.5 异常解决后我们再进行测试已经可以正常地跳转到hello.html页面，并显示了登录的用户名 8.6 最后我们点击退出登录，即可完成注销操作（此时地址栏”/login?logout”，并且跳回登录页面提示”你已经退出登录”） 九、总结恭喜！你已经开发了一个简单的Spring Security程序。 常见问题【问题一】： 在测试中，我们正常登录时候出现了异常：java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id “null” 【解答】：通过问题我们知道该异常来自认证信息WebSecurityConfig的方法configure(AuthenticationManagerBuilder)。所以我们查阅官方文档，发现在spring boot 2.0之上使用的是Spring Security 5.0版本，同时也指出使用密码校验时候需要进行密码加密。 因此，改动如下：1234567891011121314151617181920212223&gt; 方法1：在Application.java启动类下加入该方法，关闭密码加密校验.(不推荐)&gt; @Bean&gt; public static PasswordEncoder passwordEncoder() &#123;&gt; return NoOpPasswordEncoder.getInstance();&gt; &#125;&gt; &gt; 方法2：在WebSecurityConfig.java类的configure(AuthenticationManagerBuilder)进行如下改动&gt; @Override&gt; protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;&gt; // auth.inMemoryAuthentication() // 在内存中进行身份验证&gt; // .withUser(&quot;user&quot;)&gt; // .password(&quot;password&quot;)&gt; // .roles(&quot;USER&quot;);&gt; &gt; auth.inMemoryAuthentication() // 在内存中进行身份验证&gt; .passwordEncoder(new BCryptPasswordEncoder())&gt; .withUser(&quot;user&quot;)&gt; .password(new BCryptPasswordEncoder().encode(&quot;123456&quot;))&gt; .roles(&quot;USER&quot;);&gt; &gt; // auth.userDetailsService(userService).passwordEncoder(new BCryptPasswordEncoder());&gt; &#125;&gt; 小技巧在我们开发的过程中，我们经常会遇到修改一点点东西时候，都需要重启操作来生效。因此，spring boot为我们提供了一个devTool热更新工具，无需重启即可生效 pom.xml中引入相关jar123456789101112131415161718&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; ... &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt;...&lt;dependencies&gt; 如何使用 【提示】: 由于我自己使用的是idea进行开发,因此对eclipse的引入是否需要快捷键并不是很清楚，提供了相关链接 IDEA使用： 修改了java类的地方，使用Ctrl+Shift+F9进行热更新 静态页面/模板页面，使用Ctrl+F9进行热更新 快捷键使用后不生效？前往File-Settings-Compiler-Build Project automatically选项开始idea自动编译 eclipse使用： 直接引入 不生效？Eclipse热部署 附录：HttpSecurity类的常用方法 方法 说明 openidLogin() 基于OpenId验证 headers() 将安全头添加到响应 cors() 跨域配置 sessionManagement() session会话管理 portMapper() 配置一个PortMapper(HttpSecurity#(getSharedObject(class)))，供SecurityConfigurer对象使用 PortMapper 从 HTTP 重定向到 HTTPS 或者从 HTTPS 重定向到 HTTP。默认情况下，Spring Security使用一个PortMapperImpl映射 HTTP 端口8080到 HTTPS 端口8443，HTTP 端口80到 HTTPS 端口443 jee() 配置容器预认证，默认为Servlet容器进行管理 x509() 配置x509认证 rememberMe() 配置“记住我”的验证 authorizeRequests() 允许HttpServletRequest限制访问 requestCache() 允许配置请求缓存 exceptionHandling() 允许配置错误处理 logout() 退出登录。访问URL”/ logout”，使HTTP Session无效来清除用户，清除已配置的任何#rememberMe()身份验证，清除SecurityContextHolder，然后重定向到”/login?logout” anonymous() 允许配置匿名用户访问。默认情况下，匿名用户将使用org.springframework.security.authentication.AnonymousAuthenticationToken表示，并包含角色 “ROLE_ANONYMOUS” formLogin() 指定用于表单身份验证。 oauth2Login() 用于OAuth 2.0 或OpenID的身份验证 requiresChannel() 配置通道安全。 httpBasic() 配置Http Basic验证 addFilterAt() 在指定的Filter类位置添加过滤器","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.ffspace.cn/categories/后端/"},{"name":"Spring Security","slug":"后端/Spring-Security","permalink":"https://blog.ffspace.cn/categories/后端/Spring-Security/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://blog.ffspace.cn/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://blog.ffspace.cn/tags/Spring-Security/"}]}]}